= Capabilities & seccomp_filter
Felix Meulenkamp <lix@redhat.com>

== Background

.Links
* https://en.wikipedia.org/wiki/System_call
* https://man7.org/linux/man-pages/man7/capabilities.7.html
* https://www.kernel.org/doc/html/latest/security/credentials.html Ebenfalls Caps
* https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt
* https://www.kernel.org/doc/html/latest/userspace-api/seccomp_filter.html
* https://en.wikipedia.org/wiki/Linux_kernel_interfaces
* https://en.wikipedia.org/wiki/Capability-based_security#POSIX_capabilities

.Silberschatz
* ~~ABI application binary interface 82-83~~
* syscall ~22~,66-78
* ~~syscall firewall 708~~
* syscall filter (SECCOMP-BPF) 738
* capabilities ~730~,~732-733~,735-737,~747~
* capabilities protection system 735-737
* Berkeley Packet Filter (BPF) 102-104

== Script

**Teaser**

* Bist du kein root? Darfst du nichts?
* Wie entscheidet der Kernel, was dein Programm darf und was nicht?
* Und was macht da eine Firewall in meinem Kernel?

**Tagline**

* Hi, ich bin Felix Meulenkamp
* Consulting Architect für OpenShift Clouds bei Red Hat
* und ich erkläre euch in dieser Reihe Linux Security Basics

**System Calls**

System Calls oder kürzer, Syscalls, stellen die Schnittstelle für Programme auf Funktionen des Kernels dar

Damit man nicht alles ständig neu entwickeln muss nutzen Programme verschiedene Bibliotheken, sogenannte Libraries, kurz Libs, wie zB die `glibc`, die zentrale C Lib von GNU/Linux, in der verschiedene Funktionen schon fertig enthalten sind.

Brauche ich eine Eingabe oder möchte einfach nur eine Datei lesen, so kann ich die entsprechenden Funktionen aus der Bilbliothek nutzen.

Um jedoch eine Datei lesen zu können und dies nicht für jedes Dateisystem neu zu implementieren, bilden diese Bibliotheken auf die entsprechenden Syscalls des Kernels ab.

Dies schafft auch eine gewisse Unabhängigkeit von dem genauen Betriebssystem und der Architektur des Rechners.

die Libs der Programmiersprachen stellen ein stabiles Application Programming Interface, eine API, zur Verfügung und dieses verwendet dann die entsprechenden syscalls des Betriebssystems.

Es gibt Syscalls für alle möglichen Funktionen... Prozesse erzeugen und beenden, Dateien lesen und schreiben, Netzwerk Verbindungen lesen und schreiben und und und...

Verschieden Subsysteme, wie das Filesystem oder das Netzwerk werden so abstrahiert und als System Call Interfaces bezeichnet.


**Capabilities**

Da Syscalls tief in das System greifen, wurde früh nach einer Möglichkeit gesucht den Zugriff auf diese zu beschränken.

Deshalb wurden früh zwischen unpriviligierten und priviligierten Usern unterschieden.

Zunächst recht einfach, alles was mit effektiver UID 0 läuft ist Priviligiert und ignoriert damit alle sicherheitchecks im Kernel.

Alle anderen Nutzer waren somit von vielen Funktionen ausgesperrt.

Das Konzept wurde schliesslich um Gruppen erweitert und somit war es plötzlich auch möglich über Gruppenmitgliedschaften einige Rechte zu erlangen.

Damit nun einige harmlose Programme auf priviligierte Aktionen durchführen können wurden Konstrukte wie das SUID- oder SGID-Bits, auch UNIX exec privilege escalation bits, eingeführt.

Beispiel:
[source,console]
----
# Find SUID-Bit
$ sudo find /usr/bin /usr/lib -perm /4000 -user root
/usr/bin/chage
/usr/bin/newgrp
/usr/bin/pkexec
/usr/bin/gpasswd
/usr/bin/su
/usr/bin/vmware-user-suid-wrapper
/usr/bin/sudo
/usr/bin/umount
/usr/bin/passwd
/usr/bin/mount
/usr/bin/fusermount
/usr/bin/fusermount3
/usr/lib/polkit-1/polkit-agent-helper-1

# Find SGID-Bit
$ sudo find /usr/bin /usr/lib -perm /2000 -user root
/usr/bin/write
/usr/bin/locate
----

Ein Programm mit einem solchen Bit gesetzt, läuft nicht unter dem Benutzer der es startet, sondern dem Benutzer dem es gehört.

Damit wird es Möglich zum Beispiel den `ping` -Befehl auch als normaler Benutzer zu nutzen, obwohl er einige Sonderrechte für das Netzwerk benötigt.

Dieses Konzept war jedoch immer noch leicht angreifbar, da eine Schwachstelle in einem solchen Programm nun ggfs. zu vollen Root-Rechten führte.

In meinen frühen Jahren als Unix System Betreuer, hatte ich zB. einen Kollegen der eine ungepatchte Version des Tools `finger` regelmäßig dazu nutzte um einen Kundenserver mit wechselnden Root Passwörtern zu betreuen ohne sich jedes Mal das Passwort neu beschaffen zu müssen.

Diese extrem grobe Aufteilung reichte somit nicht aus und die Rechte wurden in Capabilities aufgeteilt.

Caps sind seit Linux 2.2 und somit seit etwa 1999 im Linux Kernel enthalten.

Eine Bit-Maske regelt welche Caps für ein Program erlaut sind und welche nicht.

Es wurden 64Bit hierfür vorgesehen, welche jedoch schnell knapp wurden.

Dies führte dazu, das die einzelnen Caps zu Gruppen wurden, die bestimmt Funktionalitäten bündeln.

XXX File Cap hier einbauen

* abgabe bestimmter Caps, wenn nicht mehr benötigt

Zum Beispiel Apache braucht erhöhte Rechte und die Cap `CAP_NET_BIND_SERVICE` um Port 80 zu binden und gibt danach cap ab und wird zu User `Nobody`

* Vorteil Container: Nicht die Anwendung sondern die Container Run-time gibt die Caps ab
* Teil der Metadaten eines Containers in Kubernetes
* Arten von Capabilities
* Einige wichtige Beispiele
* File Caps
*  POSIX.1e Standart
* Linux Security Module
* xAttr `security.capability`

Beispiel:

[source:console]
----
$ sudo getfattr -d -m security.capability /usr/bin/*
getfattr: Removing leading '/' from absolute path names
# file: usr/bin/arping
security.capability=0sAAAAAgAgAAAAAAAAAAAAAAAAAAA=

# file: usr/bin/clockdiff
security.capability=0sAAAAAgAgAAAAAAAAAAAAAAAAAAA=

# file: usr/bin/gnome-keyring-daemon
security.capability=0sAQAAAgBAAAAAAAAAAAAAAAAAAAA=

# file: usr/bin/gnome-shell
security.capability=0sAQAAAgAAgAAAAAAAAAAAAAAAAAA=

# file: usr/bin/newgidmap
security.capability=0sAQAAAkAAAAAAAAAAAAAAAAAAAAA=

# file: usr/bin/newuidmap
security.capability=0sAQAAAoAAAAAAAAAAAAAAAAAAAAA=

# file: usr/bin/ping
security.capability=0sAAAAAgAwAAAAAAAAAAAAAAAAAAA=
----


**Seccomp**

Grenze zwischen Kernel und User-Mode

* Syscalls sind zu grob in Caps eingeteilt
* Weitere Unterteilung dank BPF
*
